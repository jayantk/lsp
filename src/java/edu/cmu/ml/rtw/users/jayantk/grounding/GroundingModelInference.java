package edu.cmu.ml.rtw.users.jayantk.grounding;

import java.util.List;

import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.jayantkrish.jklol.cfg.BeamSearchCfgFactor;
import com.jayantkrish.jklol.cfg.ParseTree;
import com.jayantkrish.jklol.models.DiscreteObjectFactor;
import com.jayantkrish.jklol.tensor.Tensor;
import com.jayantkrish.jklol.util.Assignment;

/**
 * Approximate inference for grounding model.
 * 
 * @author jayantk
 */
public class GroundingModelInference {

  private final int maxParses;
  private final Function<QueryTree, MultiTree<Tensor>> inferenceAlgorithm;
  
  public GroundingModelInference(Function<QueryTree, MultiTree<Tensor>> inferenceAlgorithm, int maxParses) {
    this.inferenceAlgorithm = Preconditions.checkNotNull(inferenceAlgorithm);
    this.maxParses = maxParses;
  }

  public GroundingInference getConditionalPrediction(GroundingModel model, Domain domain,
      List<String> parserInput, Tensor expectedGroundingWeights) {
    // These store the highest-weight unconditional prediction and
    // prediction
    // conditioned on the output.
    ParseTree bestParse = null;
    MultiTree<Tensor> bestGrounding = null;
    MultiTree<Tensor> bestUnconditionalGrounding = null;
    QueryTree bestQuery = null;
    double bestWeight = Double.NEGATIVE_INFINITY;
    double bestParseWeight = Double.NEGATIVE_INFINITY;
    double bestGroundingWeight = Double.NEGATIVE_INFINITY;

    BeamSearchCfgFactor parser = model.getParser();
    DiscreteObjectFactor parseFactor = parser.conditional(
        parser.getTerminalVariable().outcomeArrayToAssignment(parserInput))
        .coerceToDiscreteObject();
    for (Assignment parseAssignment : parseFactor.getMostLikelyAssignments(maxParses)) {
      // For each parse tree generated by the beam search, instantiate
      // its grounding factor graph and perform inference.
      ParseTree parse = (ParseTree) parseAssignment.getOnlyValue();
      // System.out.println(parse);
      double parseWeight = parseFactor.getUnnormalizedLogProbability(parseAssignment);

      // Instantiate the factor graph (/ probabilistic database query)
      // corresponding to the current parse tree. Identify the best
      // predicted grounding for this tree.
      QueryTree queryGraph = model.getQueryFromParse(parse, domain, false);

      // Get the weight of the best grounding with no conditioning on
      // its output. This value controls for the fact that not all
      // predicates in the database occur in every logical form.
      MultiTree<Tensor> bestUnconditionalAssignment = queryGraph.locallyDecodeVariables();
      double unconditionalWeight = queryGraph.getWeight(bestUnconditionalAssignment);

      // Instantiate factor graph (/ probabilistic database query),
      // incorporating the observed grounding weights.
      QueryTree conditionalQueryGraph = model.getQueryFromParse(parse, domain, false);
      conditionalQueryGraph.updateOutputLocalWeights(expectedGroundingWeights);
      MultiTree<Tensor> bestConditionalAssignment = inferenceAlgorithm.apply(conditionalQueryGraph);
      
      // System.out.println(queryGraph.getAssignmentString(bestConditionalAssignment));
      QueryTree conditionalQueryGraphScorable = model.getQueryFromParse(parse, domain, false);
      double conditionalGroundingWeight = conditionalQueryGraphScorable.getWeight(bestConditionalAssignment) - unconditionalWeight;

      if (Double.isInfinite(bestWeight) || parseWeight + conditionalGroundingWeight >= bestWeight) {
        bestParse = parse;
        bestUnconditionalGrounding = bestUnconditionalAssignment;
        bestGrounding = bestConditionalAssignment;
        bestQuery = queryGraph;
        bestParseWeight = parseWeight;
        bestGroundingWeight = conditionalGroundingWeight;
        bestWeight = parseWeight + conditionalGroundingWeight;
      }

      // System.err.println("grounding weight " + groundingWeight);
      Preconditions.checkState(!Double.isNaN(parseWeight), "Parse Weights are NaN");
      Preconditions.checkState(!Double.isNaN(conditionalGroundingWeight), "Conditional Weights are NaN");
    }

    Preconditions.checkState(bestParse != null, "No parse of: " + parserInput);
    
    return new GroundingInference(bestParse, bestQuery, bestGrounding, bestUnconditionalGrounding,
        bestWeight, bestParseWeight, bestGroundingWeight);
  }

  public static class GroundingInference {
    private final ParseTree bestParse;
    private final QueryTree bestQuery;
    private final MultiTree<Tensor> bestAssignment;
    private final MultiTree<Tensor> bestUnconditionalAssignment;

    private final double weight;
    private final double parseWeight;
    private final double groundingWeight;
    
    public GroundingInference(ParseTree bestParse, QueryTree bestQuery, MultiTree<Tensor> bestAssignment, 
        MultiTree<Tensor> bestUnconditionalAssignment, double weight, double parseWeight, double groundingWeight) {
      this.bestParse = bestParse;
      this.bestQuery = bestQuery;
      this.bestAssignment = bestAssignment;
      this.bestUnconditionalAssignment = bestUnconditionalAssignment;
      this.weight = weight;
      this.parseWeight = parseWeight;
      this.groundingWeight = groundingWeight;
    }

    public ParseTree getBestParse() {
      return bestParse;
    }

    public QueryTree getBestQuery() {
      return bestQuery;
    }

    public MultiTree<Tensor> getBestAssignment() {
      return bestAssignment;
    }

    public MultiTree<Tensor> getBestUnconditionalAssignment() {
      return bestUnconditionalAssignment;
    }

    public double getWeight() {
      return weight;
    }

    public double getParseWeight() {
      return parseWeight;
    }

    public double getGroundingWeight() {
      return groundingWeight;
    }
  }
}
